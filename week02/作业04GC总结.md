## 总结

### 1 Serial GC

* MinorGC: DefNew回收器，标记-复制算法，STW。
* MajorGC: Tenured回收器，标记-清除-整理算法，STW。作为CMS的后备预案，在并发收集发生Concurrent Mode Failure时使用。
* 因为GC是单线程的，比较适合单核机器，在多核机器上因为整个GC过程都是STW不能充分利用CPU资源，应用延迟会相对比较高。
* GC后存活对象越多，GC耗时会越高，所以内存配置的比较大的话GC耗时会很多，服务端一般不采用串行GC

### 2 Parallel GC

* MinorGC: Parallel Scavenge回收器, 多个线程并行收集，标记-复制算法，STW
* MajorGC: Parallel Old回收器，多个线程并行收集，标记-清除-整理算法，STW
* 多核机器下，相比Serial GC回收耗时要短很多
* CPU要么全部做GC，要么全部做业务，比较适合计算为主的后台应用

### 3 CMS GC

* MinorGC: ParNew回收器，多线程并行收集，标记-复制算法，STW
* MajorGC: CMS回收器，只收集老年代，标记-清除算法，分阶段执行，只有初始标记、最终标记阶段有STW，其它阶段和应用线程并发。分为以下7阶段
  * `初始标记`：STW, 标记GC Roots，GC Roots直接应用的对象，标记Old区被Young区存活对象直接引用的对象
  * `并发标记`：并发，根据`初始标记`的GC Roots遍历Old区所有存活对象，
  * `并发预清理`: 并发，使用卡片标记 `并发标记`引用发生变化的对象大致区域，即脏区，期间可能伴随多次MinorGC
  * `可取消的并发预清理`: 尽可能在`最终标记`前等待够长的时间，为`最终标记`多干些活，尽量降低STW的时间，当满足一定条件自动终止
  * `最终标记`：STW, 标记Old区所有存活对象，
  * `并发清理`: 并发，清理死亡的对象。
  * `并发重置`：并发，重置各种CMS参数，为下一次CMS循环准备。
* 因为CMS没有整理（使用空闲列表标记可用内存），因此会产生许多碎片，如果碎片太多以至于没有足够的空间放置从Young区晋升的对象或者直接分配的大对象，就会临时开启Serial Old清理老年代。
* 由于分阶段，并发，延迟相对Serial，Paralell低，比较适合交互较多的B/S服务端

### 4 G1 GC

* Heap划分成N个region, 每个region可能是Eden,S0,S1,old

* 每次GC都会收集young区，但是old区只会收集一部分。收集的对象集合称为collection set(日志里Cset)

* YoungGC ：Evacuation, 并行，STW, 标记-复制算法。最开始只有young区，当young区满了，存活对象被拷贝到存活区，如果没有存活区就任意选择一部分regions作为存活区

* 并发标记: 当堆内存使用比例达到 `initiatingHeapOccupancyPercent`触发，默认45%

  * `初始标记`: STW, 标记所有GCRoots直接可达对象
  * `根区扫描`: 并发，从初始标记的存活区扫描并标记对老年代的引用。并且只有完成该阶段后才能进行下一次STW年轻代垃圾回收
  * `并发标记`:并发，标记堆中所有存活对象。
  * `再次标记`:STW，标记所有并发标记阶段没有标记的存活对象
  * `清理`: 并发，STW都存在，统计region中存活的对象，并排序，为MixedGC打基础。此阶段，所有不包含存活对象的区域直接回收了

* MixedGC : STW, Evacuation : 回收young区+根据并发标记的结果优先收集垃圾比较多的old区。 在并发标记、MixedGC之间可能有多次ygc。

  